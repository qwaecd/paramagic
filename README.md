# 参数魔法 (Paramagic)

## 基本设定

### 名词解释

英文释义优先，中文释义按 mod 描述选取和定义。

**说明格式**
```
英文释义（中文释义）：中文解释
```

- **para (参数单元)**：构成魔法的基础模块。每个“参数单元”都包含一种几何图形，是魔法阵视觉和功能的基本载体。取自 "parameter"。
- **paralgorhythm (参数算法式)**：由多个“参数单元”以树状结构组合而成的完整魔法。它不仅定义了魔法阵的华丽外观和动态效果，还决定了最终释放的魔法效果。取自 "parameter" + "algorithm" + "rhythm"。

## 玩法介绍

在“参数魔法”中，你不是学习固定的咒语，而是成为魔法的设计者。一个完整的魔法（`paralgorhythm`）由你亲手分步构建，主要包括 **设计外观** 和 **定义功能** 两个核心步骤。

### 步骤一：设计魔法阵的外观

魔法始于构图。你需要创建数个“参数单元”（`para`），并为它们指定不同的几何图形（如圆形、三角形、正方形等）。

随后，你需要像搭建积木一样，将这些“参数单元”以父子关系组合成一个树状结构。这个结构就是你魔法阵的蓝图，它不仅决定了各个几何图形的相对位置，也为后续的功能定义打下了基础。

**示例：**
1.  创建四个参数单元：A (正方形), B (三角形), C (圆形), D (五角星)。
2.  搭建结构：
    - 将 B 和 C 设置为 A 的子单元。
    - 将 D 设置为 B 的子单元。
    - 最终形成 `D -> B -> A` 和 `C -> A` 的树状结构。

### 步骤二：定义魔法的功能

外观只是起点，功能才是魔法的灵魂。你需要为你创建的每个“参数单元”赋予具体的魔法效果。这些效果大致可以分为三类：

- **核心效果**：决定魔法的本质，例如“爆炸”、“治疗”或“召唤闪电”。通常由树结构的根节点承担。
- **目标指令**：决定魔法在哪里或对谁生效，例如“指向视线所及的方块”、“指向自身”或“影响半径5米内的所有生物”。
- **修饰效果**：调整或增强其他效果，例如“强度加倍”、“范围扩大”、“延迟触发”或“持续燃烧”。

当魔法被释放时，所有“参数单元”的效果会根据它们在树状结构中的位置进行算法组合，最终呈现出一个独一-无二的法术。

**重要规则：**
- **修饰范围**：子节点的修饰效果 **只会** 影响其直接的父节点。
- **效果冲突**：当存在多个同类效果（如多个目标指令）时，系统在遍历树结构时， **后处理的效果会覆盖先处理的**。 (注意：该部分算法仍在开发中，具体表现未来可能调整。)

**续上例：**
1.  为根单元 **A (正方形)** 定义核心效果：**“爆炸”**。
2.  为子单元 **C (圆形)** 定义目标指令：**“指向面前的方块”**。
3.  为子单元 **B (三角形)** 定义修饰效果：**“强度加强”**。
4.  为孙单元 **D (五角星)** 定义修饰效果：**“效果数值x2”**。

**最终效果：**
> 根据规则，D 的“x2”效果作用于其父节点 B，使 B 的效果变为“双倍的强度加强”。然后，这个新效果与 C 的目标指令一同作用于根节点 A。
>
> 最终效果为：在 **{面前的方块}** 上，执行一次 **{爆炸}**，其爆炸强度受到了 **{双倍的强度加强}** 效果的增幅。

通过这种方式，你可以自由组合，创造出威力强大、功能独特的原创魔法！

### (可选) 步骤三：添加动画

当你的魔法可以正常运作后，还可以为其附加动画器。你可以设计每个几何图形的旋转、缩放、发光等视觉特效，让你的魔法阵在施放时更加炫酷。

这部分是 **纯粹的视觉效果**，不会影响法术的实际功能（如伤害、范围）或施法时间。

## 法术执行系统

## 1. 核心设计理念

-   **玩家视角 (UX)**：直观的 **“挂载式”** 逻辑。子 Para (如“火焰修饰”) 挂载在父 Para (如“投射物”) 下，直觉上认为是子节点在修饰父节点。
-   **底层实现 (Dev)**：基于 **Step (步进流程)** 的 **“聚合-结算”** 模式。系统不直接按树形拓扑依次执行效果，而是先收集当前 Step 内所有 Para 的数据，汇总后统一执行。

## 2. 术语定义

-   **Para (参数单元)**：法术构成的基本节点，包含外观（几何体）和逻辑定义（Action/Modifier）。
-   **Step (步进流程)**：法术执行的最小时间片或逻辑单元。一个完整的法术可能由单个 Step 完成（瞬发），也可能由多个 Step 序列完成（持续施法/多重连发）。
-   **Context (执行上下文)**：一个临时的数据黑板，用于在单个 Step 内存储从各个 Para 收集来的参数。
-   **Instability (不稳定度)**：限制法术复杂度的数值系统，随 Step 执行累积。

## 3. 执行管线 (The Execution Pipeline)

法术执行遵循 **“收集 (Collect) -> 结算 (Resolve)”** 的两阶段原则，完全发生在一个 Step 流程内。

### 阶段 I：作用域界定 (Scoping)
系统首先确定本次 Step 需要纳入哪些 Para。
-   **默认规则**：包含当前执行游标所在的 **根 Para** 及其 **所有直接子 Para**。
-   **流控例外**：如果存在“流程控制类” Para（如：`AndGate`, `Sequence`），作用域可能向下延伸，将孙节点也纳入本次 Step。

### 阶段 II：数据聚合 (Aggregation Phase)
**这是解决“修饰符”逻辑的核心环节。**
系统遍历作用域内的所有 Para，调用其 `onCollect(Context)` 方法。

1.  **行为**：此时 **不产生** 任何实际的游戏世界影响（不生成实体，不扣血）。
2.  **数据写入**：
    -   **修饰类 Para** (Modifier)：向 `Context` 写入或修改参数（例：`damage_mult += 0.5`，`element = FIRE`）。
    -   **核心类 Para** (Action)：向 `Context` 注册意图（例：`actions.add(SPAWN_PROJECTILE)`）。
3.  **覆盖规则**：若多个 Para 修改同一参数（如目标指令），后遍历到的 Para 数据覆盖旧数据（或根据特定逻辑进行堆叠）。
4.  **不稳定度计算**：
    -   每遍历一个 Para，根据其复杂度增加 `Instability`。
    -   若 `Instability` 超过阈值，标记 `Context.isOverloaded = true`。

### 阶段 III：统一结算 (Resolution Phase)
数据收集完毕，`Context` 已包含本次 Step 的所有特征。系统调用 `resolve(Context)`。

1.  **过载检查**：
    -   若 `Context.isOverloaded` 为真，取消正常结算，执行 **“法术反噬/炸膛”** 逻辑。
2.  **意图实例化**：
    -   读取 `Context.actions`。
    -   例如读取到 `SPAWN_PROJECTILE`，则根据 `Context` 中的参数（伤害、速度、材质、模型）在世界中生成实体。
3.  **脱离控制 (Fire & Forget)**：
    -   实体一旦生成，即刻脱离法术系统的控制。
    -   实体属性（NBT）在生成瞬间已固化（Snapshot），不受后续 Step 影响。


## 开发进度

### 已完成
- 与 Minecraft 解耦的底层渲染系统
- Bloom 效果
- 基本 Para 的渲染实现
- 数据驱动的魔法阵构建
- 数据驱动的关键帧动画以及动画与法阵的结合
- GPU 粒子
- 挂载到 Entity 上的魔法阵
- 服务端客户端数据/动画同步

### 待完成
- 将瞬发框架改为解释执行逻辑

### 计划中
- GPU 粒子变图元
- ~~(画饼) GPU 粒子与世界的碰撞交互~~

## 信息
### OpenGL
- 本 mod 直接使用 OpenGL 进行渲染，可能与某些光影或其他优化 OpenGL 的 mod 存在兼容性问题。比如 Iris 的特定光影会出现遮挡错误的问题。
- 推荐使用 OpenGL 4.3 及以上版本，最低 OpenGL 版本为 3.2，低于该版本的 OpenGL 可能无法正常运行。
- 低于 OpenGL 4.3 的版本可能会出现部分功能不可用的情况，取决于显卡驱动的实现。如果遇到渲染问题，建议尝试更新显卡驱动，或者提升 OpenGL 版本。