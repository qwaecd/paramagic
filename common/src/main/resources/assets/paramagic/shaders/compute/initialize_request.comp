#version 430 core
#define BINDING_GLOBAL_DATA 0
#define BINDING_PARTICLE_DATA 1
#define BINDING_DEAD_LIST 2
#define BINDING_REQUESTS 4
#define BINDING_EMISSION_TASKS 5
#define LOCAL_SIZE_X 256

// Mathematical constants
#define PI 3.141592654

layout(local_size_x = LOCAL_SIZE_X, local_size_y = 1, local_size_z = 1) in;

struct GlobalCounters {
    uint deadListStackTop;  // Number of available (dead) particle slots
    uint successfulTaskCount;   // Number of tasks written so far
    uint _padding2;
    uint _padding3;
};

struct EmissionRequest {
    int count;
    int emitterType;
    int effectId;
    int _padding;

    vec4 param1;
    vec4 param2;
    vec4 param3;
    vec4 param4;
    vec4 param5;
};

struct Particle {
    vec4 meta;        // x: effectId, y: unused, z: unused, w: unused
    vec4 position;    // x, y, z, mass(unused)
    vec4 velocity;    // vx, vy, vz, (unused)
    vec4 attributes;  // x: age, y: lifetime, z: current_anim_frame, w: anim_speed
    vec4 renderAttribs;  // x: size, y: angle, z: angular_velocity, w: bloom_intensity
    vec4 color; // rgba
};

struct EmissionTask {
    uint numParticlesToInit;
    uint indexStackOffset;
    uint _padding0;
    uint _padding1;
    EmissionRequest request;
};

layout(std430, binding = BINDING_GLOBAL_DATA) buffer Globals {
    GlobalCounters globalData;
};
layout(std430, binding = BINDING_REQUESTS) buffer ParticleRequests {
    EmissionRequest requests[];
};
layout(std430, binding = BINDING_PARTICLE_DATA) buffer ParticleData {
    Particle particles[];
};
layout(std430, binding = BINDING_DEAD_LIST) buffer DeadList {
    uint deadList[];
};
layout(std430, binding = BINDING_EMISSION_TASKS) buffer Tasks {
    EmissionTask emissionTasks[];
};

uniform float u_randomSeed;

subroutine void EmitterInitializer(uint particleIndex, EmissionRequest req);
subroutine uniform EmitterInitializer u_emitterInitializerFunc;

// emitter types
const int POINT_EMITTER = 1;
const int LINE_EMITTER = 2;
const int SPHERE_EMITTER = 3;
const int CUBE_EMITTER = 4;

// emitter flags
const uint EMITTER_FLAGS_EMIT_FROM_VOLUME = (1u << 0);

const uint VELOCITY_MODE_OFFSET = (1u);
const uint EMITTER_FLAGS_VELOCITY_MODE_CONE = ((1u << 0) << VELOCITY_MODE_OFFSET); // 001X
const uint EMITTER_FLAGS_VELOCITY_MODE_RANDOM = ((1u << 1) << VELOCITY_MODE_OFFSET); // 010X
const uint EMITTER_FLAGS_VELOCITY_MODE_RADIAL_FROM_CENTER = ((1u << 1 | 1u) << VELOCITY_MODE_OFFSET); // 011X
const uint EMITTER_FLAGS_VELOCITY_MODE_DIRECT = ((1u << 2) << VELOCITY_MODE_OFFSET); // 100X
// flags masks emitFromVolume
const uint EMITTER_MASK_EMIT_FROM_VOLUME = (1u << 0); // 0001
const uint EMITTER_MASK_VELOCITY_MODE = (7u << 1); // 1110

// --- Random utilities ---
// 32-bit mix hash (variant of Wang/Jenkins style) producing good bit diffusion.
uint hashUint(uint x) {
    x ^= x >> 16;
    x *= 0x7feb352du;
    x ^= x >> 15;
    x *= 0x846ca68bu;
    x ^= x >> 16;
    return x;
}

// Convert hashed uint to float strictly inside (0,1) by adding 0.5 then dividing by 2^32.
float uintToUnitExclusive(uint h) {
    return (float(h) + 0.5) / 4294967296.0; // 4294967296 = 2^32
}

float random(float offset) {
    uint seed = floatBitsToUint(u_randomSeed + offset);
    seed ^= gl_GlobalInvocationID.x * 0x9E3779B1u;
    seed ^= gl_GlobalInvocationID.y * 0x85EBCA77u;
    seed ^= gl_GlobalInvocationID.z * 0xC2B2AE3Du;
    seed ^= gl_WorkGroupID.x        * 0x27D4EB2Fu;
    seed ^= gl_WorkGroupID.y        * 0x165667B1u;
    seed ^= gl_WorkGroupID.z        * 0xD3A2646Cu;
    seed ^= gl_LocalInvocationID.x  * 0x94D049BBu;

    // Finalize with strong mixing and map to (0,1)
    return uintToUnitExclusive(hashUint(seed));
}
float randomFloatInRange(float min, float max, float offset) {
    return random(offset) * (max - min) + min;
}
// --- End random utilities ---

bool hasAnyFlag(uint flagsToCheck, uint targetFlag) {
    return (flagsToCheck & targetFlag) != 0u;
}

/**
 * Check flagsToCheck's specific field against a target pattern.
 */
bool fieldEquals(uint flagsToCheck, uint fieldMask, uint targetPattern) {
    uint isolatedField = flagsToCheck & fieldMask;

    return isolatedField == targetPattern;
}

/**
 * 从单个向量 a_axis 构建一个标准正交基（一个坐标系）
 * a_axis:      输入的向量，将成为新坐标系的 Z 轴
 * out_axis_x:  输出的 X 轴
 * out_axis_y:  输出的 Y 轴
 * out_axis_z:  输出的 Z 轴（归一化后的 a_axis）
 */
void buildOrthonormalBasis(vec3 a_axis, out vec3 out_axis_x, out vec3 out_axis_y, out vec3 out_axis_z) {
    out_axis_z = normalize(a_axis);

    vec3 temp_up;
    if (abs(out_axis_z.y) > 0.999) {
        temp_up = vec3(1.0, 0.0, 0.0);
    } else {
        temp_up = vec3(0.0, 1.0, 0.0);
    }

    out_axis_x = normalize(cross(temp_up, out_axis_z));
    out_axis_y = cross(out_axis_z, out_axis_x);
}

/**
 * struct Particle {
 *   vec4 meta;     // x: effectId, y: unused, z: unused, w: unused
 *   vec4 position;    // x, y, z, mass
 *   vec4 velocity;    // vx, vy, vz, (unused)
 *   vec4 attributes;  // x: age, y: lifetime, z: current_anim_frame, w: anim_speed
 *   vec4 renderAttribs;  // x: size, y: angle, z: angular_velocity, w: bloom_intensity
 *   vec4 color;
 * };
 */
void pointEmitter(uint particleIndex, EmissionRequest req, uint unique_ID) {
    // Gram-Schmidt process
    vec3 axisX, axisY, axisZ;
    buildOrthonormalBasis(req.param2.xyz, axisX, axisY, axisZ);
    float phi = random(1.0 + float(unique_ID)) * 2.0 * PI;
    float cos_theta = mix(cos(radians(req.param5.x)), 1.0, random(1.1 + float(unique_ID)));
    float sin_theta = sqrt(1.0 - cos_theta * cos_theta);
    float x = sin_theta * cos(phi);
    float y = sin_theta * sin(phi);
    float z = cos_theta;
    vec3 local_dir = vec3(x, y, z);
    vec3 random_dir_world = local_dir.x * axisX + local_dir.y * axisY + local_dir.z * axisZ;
    vec3 initial_velocity = random_dir_world * length(req.param2.xyz);


    particles[particleIndex].meta = vec4(float(req.effectId), 0.0, 0.0, 0.0);
    particles[particleIndex].position = req.param1;
    particles[particleIndex].velocity = vec4(initial_velocity, req.param2.w);
    particles[particleIndex].attributes = vec4(0.0, randomFloatInRange(req.param4.x, req.param4.y, 1.2 + float(unique_ID)), 0.0, 0.0);
    particles[particleIndex].renderAttribs = vec4(randomFloatInRange(req.param4.z, req.param4.w, 1.3 + float(unique_ID)), 0.0, 0.0, req.param5.y);
    particles[particleIndex].color = req.param3;
}

void lineEmitter(uint particleIndex, EmissionRequest req, uint unique_ID) {
    vec3 direction = req.param2.xyz - req.param1.xyz;
    particles[particleIndex].meta = vec4(float(req.effectId), 0.0, 0.0, 0.0);
    particles[particleIndex].position = vec4(req.param1.xyz + direction * random(2.0 + float(unique_ID)), req.param1.w);
    particles[particleIndex].velocity = req.param5;
    particles[particleIndex].attributes = vec4(0.0, randomFloatInRange(req.param4.x, req.param4.y, 2.1 + float(unique_ID)), 0.0, 0.0);
    particles[particleIndex].renderAttribs = vec4(randomFloatInRange(req.param4.z, req.param4.w, 2.2 + float(unique_ID)), 0.0, 0.0, req.param5.w);
    particles[particleIndex].color = req.param3;
}

void sphereEmitter(uint particleIndex, EmissionRequest req, uint unique_ID) {
    // Gram-Schmidt process
    vec3 axisX, axisY, axisZ;

    // if (req.param2.xyz is zero) direction = vec3(0.0, 1.0, 0.0);
    float isNonZero = step(1e-6, length(req.param2.xyz));
    // isNonZero=0.0 -> direction = vec3(0.0, 1.0, 0.0)
    // isNonZero=1.0 -> direction = req.param2.xyz
    vec3 direction = mix(vec3(0.0, 1.0, 0.0), req.param2.xyz, isNonZero);
    buildOrthonormalBasis(direction, axisX, axisY, axisZ);

    float phi = random(3.0 + float(unique_ID)) * 2.0 * PI;
    float cos_theta = random(3.1 + float(unique_ID)) * 2.0 - 1.0; // uniform in [-1, 1]
    float sin_theta = sqrt(1.0 - cos_theta * cos_theta);
    float x = sin_theta * cos(phi);
    float y = sin_theta * sin(phi);
    float z = cos_theta;
    vec3 local_dir = vec3(x, y, z);
    vec3 random_dir_world = local_dir.x * axisX + local_dir.y * axisY + local_dir.z * axisZ;

    uint emitterFlags = floatBitsToUint(req.param5.z);
    uint velocityMode = emitterFlags & EMITTER_MASK_VELOCITY_MODE;

    vec3 initial_velocity;
    switch(velocityMode) {
        case EMITTER_FLAGS_VELOCITY_MODE_CONE: {
            // Cone mode
            phi = random(3.0 + float(unique_ID)) * 2.0 * PI;
            cos_theta = mix(cos(radians(req.param5.x)), 1.0, random(3.1 + float(unique_ID)));
            sin_theta = sqrt(1.0 - cos_theta * cos_theta);
            x = sin_theta * cos(phi);
            y = sin_theta * sin(phi);
            z = cos_theta;
            local_dir = vec3(x, y, z);
            random_dir_world = local_dir.x * axisX + local_dir.y * axisY + local_dir.z * axisZ;
            initial_velocity = random_dir_world * length(req.param2.xyz);
            break;
        }
        case EMITTER_FLAGS_VELOCITY_MODE_RANDOM: {
            // Random mode
            vec3 randomVec3 = vec3(random(3.6 + float(unique_ID)), random(3.7 + float(unique_ID)), random(3.8 + float(unique_ID))) * 2.0 - 1.0;
            initial_velocity = normalize(randomVec3) * length(req.param2.xyz);
            break;
        }
        case EMITTER_FLAGS_VELOCITY_MODE_RADIAL_FROM_CENTER: {
            // Radial from center
            initial_velocity = random_dir_world * length(req.param2.xyz);
            break;
        }
        case EMITTER_FLAGS_VELOCITY_MODE_DIRECT:
        default: {
            // direct mod
            initial_velocity = req.param2.xyz;
            break;
        }
    }

    float isVolume = float(hasAnyFlag(emitterFlags, EMITTER_FLAGS_EMIT_FROM_VOLUME));
    float surfaceOffset = req.param1.w;
    float volumeOffset = pow(random(3.2 + float(unique_ID)), 1.0 / 3.0) * req.param1.w;
    float finalOffset = mix(surfaceOffset, volumeOffset, isVolume);
    vec3 particlePosition = req.param1.xyz + random_dir_world * finalOffset;

    particles[particleIndex].meta = vec4(float(req.effectId), 0.0, 0.0, 0.0);
    particles[particleIndex].position = vec4(particlePosition, req.param1.w);
    particles[particleIndex].velocity = vec4(initial_velocity * isNonZero, req.param2.w);
    particles[particleIndex].attributes = vec4(0.0, randomFloatInRange(req.param4.x, req.param4.y, 3.4 + float(unique_ID)), 0.0, 0.0);
    particles[particleIndex].renderAttribs = vec4(randomFloatInRange(req.param4.z, req.param4.w, 3.5 + float(unique_ID)), 0.0, 0.0, req.param5.y);
    particles[particleIndex].color = req.param3;
}

void cubeEmitter(uint particleIndex, EmissionRequest req, uint unique_ID) {
    vec3 minBounds = req.param1.xyz;
    vec3 maxBounds = req.param2.xyz;
    vec3 centerPos = 0.5 * (minBounds + maxBounds);

    uint emitterFlags = floatBitsToUint(req.param1.w);

    // gen position
    vec3 particlePosition;
    if (hasAnyFlag(emitterFlags, EMITTER_FLAGS_EMIT_FROM_VOLUME)) {
        // in AABB
        // pos = min + (max - min) * randomVec3
        particlePosition = minBounds + (maxBounds - minBounds) * vec3(random(4.01 + float(unique_ID)), random(4.02 + float(unique_ID)), random(4.03 + float(unique_ID)));
    } else {
        // on surface of AABB
        vec3 size = maxBounds - minBounds;
        float areaXY = size.x * size.y;
        float areaXZ = size.x * size.z;
        float areaYZ = size.y * size.z;
        float totalArea = 2.0 * (areaXY + areaXZ + areaYZ);
        float randomFace = random(4.1 + float(unique_ID));
        float faceSelector = randomFace * totalArea;

        vec2 randomUV = vec2(random(4.21 + float(unique_ID)), random(4.22 + float(unique_ID)));
        vec3 localPos;

        if (faceSelector < 2.0 * areaXY) {
            // -Z +Z
            localPos = vec3(randomUV.x * size.x, randomUV.y * size.y, 0.0);
            if (faceSelector >= areaXY) {
                // +Z
                localPos.z = size.z;
            }
            particlePosition = minBounds + localPos;
        } else if (faceSelector < 2.0 * (areaXY + areaXZ)) {
            // -Y +Y
            faceSelector -= 2.0 * areaXY;
            localPos = vec3(randomUV.x * size.x, 0.0, randomUV.y * size.z);
            if (faceSelector >= areaXZ) {
                // +Y
                localPos.y = size.y;
            }
            particlePosition = minBounds + localPos;
        } else {
            // -X +X
            faceSelector -= 2.0 * (areaXY + areaXZ);
            localPos = vec3(0.0, randomUV.x * size.y, randomUV.y * size.z);
            if (faceSelector >= areaYZ) {
                // +X
                localPos.x = size.x;
            }
            particlePosition = minBounds + localPos;
        }
    }

    // gen velocity
    uint velocityMode = emitterFlags & EMITTER_MASK_VELOCITY_MODE;
    vec3 initial_velocity;
    switch(velocityMode) {
        case EMITTER_FLAGS_VELOCITY_MODE_RANDOM: {
            // Random mode
            vec3 randomVec3 = vec3(random(4.6 + float(unique_ID)), random(4.7 + float(unique_ID)), random(4.8 + float(unique_ID))) * 2.0 - 1.0;
            initial_velocity = normalize(randomVec3) * length(req.param5.xyz);
            break;
        }
        case EMITTER_FLAGS_VELOCITY_MODE_RADIAL_FROM_CENTER: {
            // Radial from center
            vec3 random_dir_world = normalize(particlePosition - centerPos);
            initial_velocity = random_dir_world * length(req.param5.xyz);
            break;
        }
        case EMITTER_FLAGS_VELOCITY_MODE_DIRECT:
        case EMITTER_FLAGS_VELOCITY_MODE_CONE:
        default: {
            // when {cone, direct} modes, use direct mode
            initial_velocity = req.param5.xyz;
            break;
        }
    }
    particles[particleIndex].meta = vec4(float(req.effectId), 0.0, 0.0, 0.0);
    particles[particleIndex].position = vec4(particlePosition, req.param1.w);
    particles[particleIndex].velocity = vec4(initial_velocity, req.param2.w);
    particles[particleIndex].attributes = vec4(0.0, randomFloatInRange(req.param4.x, req.param4.y, 4.4 + float(unique_ID)), 0.0, 0.0);
    particles[particleIndex].renderAttribs = vec4(randomFloatInRange(req.param4.z, req.param4.w, 4.5 + float(unique_ID)), 0.0, 0.0, req.param5.y);
    particles[particleIndex].color = req.param3;
}

void main() {
    uint workGroupID = gl_WorkGroupID.x;

    if (workGroupID >= globalData.successfulTaskCount) {
        return;
    }

    EmissionTask task = emissionTasks[workGroupID];
    for (uint i = 0u; i < task.numParticlesToInit; i += uint(LOCAL_SIZE_X)) {
        uint idxInTask = i + gl_LocalInvocationID.x;
        if (idxInTask >= task.numParticlesToInit) {
            break;
        }
        uint particleId = deadList[task.indexStackOffset + idxInTask];
//        u_emitterInitializerFunc(particleId, task.request);

        switch(task.request.emitterType) {
            case POINT_EMITTER: pointEmitter(particleId, task.request, i); break;
            case LINE_EMITTER : lineEmitter(particleId, task.request, i); break;
            case SPHERE_EMITTER : sphereEmitter(particleId, task.request, i); break;
            case CUBE_EMITTER : cubeEmitter(particleId, task.request, i); break;
            default: break;
        }
    }
}

subroutine(EmitterInitializer)
void pointEmitterInitializer(uint particleIndex, EmissionRequest req) {
    return;
}

subroutine(EmitterInitializer)
void lineEmitterInitializer(uint particleIndex, EmissionRequest req) {
    return;
}

subroutine(EmitterInitializer)
void sphereEmitterInitializer(uint particleIndex, EmissionRequest req) {
    return;
}

subroutine(EmitterInitializer)
void cubeEmitterInitializer(uint particleIndex, EmissionRequest req) {
    return;
}
